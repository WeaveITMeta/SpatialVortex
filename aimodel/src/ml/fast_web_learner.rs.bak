//! Fast Web Learning Module
//!
//! Optimized web crawling and learning with:
//! - Parallel async requests with rate limiting
//! - Persistent disk cache to avoid redundant crawls
//! - Connection pooling for faster HTTP requests
//! - Smart batch processing
//!

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use std::path::Path;

/// Configuration for fast web learning
#[derive(Debug, Clone)]
pub struct FastWebConfig {
    /// Maximum concurrent requests
    pub max_concurrent: usize,
    /// Request timeout in seconds
    pub timeout_secs: u64,
    /// Delay between requests to same domain (ms)
    pub domain_delay_ms: u64,
    /// Enable persistent cache
    pub enable_cache: bool,
    /// Cache directory path
    pub cache_dir: String,
    /// Maximum results per query
    pub max_results: usize,
    /// Enable connection pooling
    pub connection_pooling: bool,
    /// Pool size per domain
    pub pool_size: usize,
}

impl Default for FastWebConfig {
    fn default() -> Self {
        Self {
            max_concurrent: 10,
            timeout_secs: 15,
            domain_delay_ms: 100,
            enable_cache: true,
            cache_dir: ".web_cache".to_string(),
            max_results: 5,
            connection_pooling: true,
            pool_size: 5,
        }
    }
}

/// Cached search result with timestamp
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CachedResult {
    pub query: String,
    pub results: Vec<crate::ml::web_knowledge::SearchResult>,
    pub timestamp: u64,
    pub hit_count: u32,
}

/// Fast web learner with caching and parallel processing
pub struct FastWebLearner {
    config: FastWebConfig,
    /// In-memory cache
    memory_cache: Arc<Mutex<HashMap<String, CachedResult>>>,
    /// Last request time per domain
    domain_last_request: Arc<Mutex<HashMap<String, Instant>>>,
    /// Cache hits statistics
    stats: Arc<Mutex<FastWebStats>>,
}

#[derive(Debug, Clone, Default)]
pub struct FastWebStats {
    pub total_queries: usize,
    pub cache_hits: usize,
    pub cache_misses: usize,
    pub network_requests: usize,
    pub errors: usize,
    pub avg_response_time_ms: f64,
}

impl FastWebLearner {
    pub fn new(config: FastWebConfig) -> Self {
        let learner = Self {
            config: config.clone(),
            memory_cache: Arc::new(Mutex::new(HashMap::new())),
            domain_last_request: Arc::new(Mutex::new(HashMap::new())),
            stats: Arc::new(Mutex::new(FastWebStats::default())),
        };
        
        // Load persistent cache if enabled
        if config.enable_cache {
            learner.load_cache();
        }
        
        learner
    }
    
    /// Check cache for query
    fn check_cache(&self, query: &str) -> Option<Vec<crate::ml::web_knowledge::SearchResult>> {
        let cache_key = Self::cache_key(query);
        
        // Check memory cache first
        if let Ok(cache) = self.memory_cache.lock() {
            if let Some(cached) = cache.get(&cache_key) {
                // Check if cache is still valid (24 hours)
                let age = Instant::now().elapsed().as_secs();
                if age < 86400 {
                    // Update stats
                    if let Ok(mut stats) = self.stats.lock() {
                        stats.cache_hits += 1;
                    }
                    return Some(cached.results.clone());
                }
            }
        }
        
        // Check disk cache
        if self.config.enable_cache {
            if let Some(cached) = self.load_from_disk(&cache_key) {
                // Add to memory cache
                if let Ok(mut cache) = self.memory_cache.lock() {
                    cache.insert(cache_key, cached.clone());
                }
                
                if let Ok(mut stats) = self.stats.lock() {
                    stats.cache_hits += 1;
                }
                return Some(cached.results);
            }
        }
        
        if let Ok(mut stats) = self.stats.lock() {
            stats.cache_misses += 1;
        }
        
        None
    }
    
    /// Cache key from query
    fn cache_key(query: &str) -> String {
        use std::hash::{Hash, Hasher};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        query.to_lowercase().hash(&mut hasher);
        format!("{:x}", hasher.finish())
    }
    
    /// Save result to cache
    fn save_to_cache(&self, query: &str, results: &[crate::ml::web_knowledge::SearchResult]) {
        let cache_key = Self::cache_key(query);
        let cached = CachedResult {
            query: query.to_string(),
            results: results.to_vec(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            hit_count: 1,
        };
        
        // Save to memory cache
        if let Ok(mut cache) = self.memory_cache.lock() {
            cache.insert(cache_key.clone(), cached.clone());
        }
        
        // Save to disk cache
        if self.config.enable_cache {
            self.save_to_disk(&cache_key, &cached);
        }
    }
    
    /// Load cache from disk
    fn load_cache(&self) {
        let cache_dir = Path::new(&self.config.cache_dir);
        if !cache_dir.exists() {
            let _ = std::fs::create_dir_all(cache_dir);
            return;
        }
        
        // Load all cache files
        if let Ok(entries) = std::fs::read_dir(cache_dir) {
            let mut loaded = 0;
            for entry in entries.flatten() {
                if let Some(filename) = entry.file_name().to_str() {
                    if filename.ends_with(".json") {
                        if let Ok(content) = std::fs::read_to_string(entry.path()) {
                            if let Ok(cached) = serde_json::from_str::<CachedResult>(&content) {
                                let cache_key = filename.trim_end_matches(".json").to_string();
                                if let Ok(mut cache) = self.memory_cache.lock() {
                                    cache.insert(cache_key, cached);
                                }
                                loaded += 1;
                                if loaded >= 1000 {
                                    // Limit memory cache size
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// Load single cached result from disk
    fn load_from_disk(&self, cache_key: &str) -> Option<CachedResult> {
        let path = Path::new(&self.config.cache_dir).join(format!("{}.json", cache_key));
        if let Ok(content) = std::fs::read_to_string(path) {
            if let Ok(cached) = serde_json::from_str::<CachedResult>(&content) {
                // Check age (7 days max for disk cache)
                let now = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs();
                if now - cached.timestamp < 604800 {
                    return Some(cached);
                }
            }
        }
        None
    }
    
    /// Save cached result to disk
    fn save_to_disk(&self, cache_key: &str, cached: &CachedResult) {
        let cache_dir = Path::new(&self.config.cache_dir);
        if let Err(_) = std::fs::create_dir_all(cache_dir) {
            return;
        }
        
        let path = cache_dir.join(format!("{}.json", cache_key));
        if let Ok(json) = serde_json::to_string(cached) {
            let _ = std::fs::write(path, json);
        }
    }
    
    /// Get statistics
    pub fn get_stats(&self) -> FastWebStats {
        self.stats.lock().unwrap_or_default().clone()
    }
    
    /// Clear cache
    pub fn clear_cache(&self) {
        if let Ok(mut cache) = self.memory_cache.lock() {
            cache.clear();
        }
        
        if self.config.enable_cache {
            let cache_dir = Path::new(&self.config.cache_dir);
            let _ = std::fs::remove_dir_all(cache_dir);
            let _ = std::fs::create_dir_all(cache_dir);
        }
    }
}

impl Default for FastWebLearner {
    fn default() -> Self {
        Self::new(FastWebConfig::default())
    }
}

impl FastWebLearner {
    /// Search with automatic caching
    pub fn search(&self, query: &str) -> Vec<crate::ml::web_knowledge::SearchResult> {
        let start = Instant::now();
        
        // Check cache first
        if let Some(cached) = self.check_cache(query) {
            return cached;
        }
        
        // Perform search
        let results = self.perform_search(query);
        
        // Save to cache
        self.save_to_cache(query, &results);
        
        // Update stats
        if let Ok(mut stats) = self.stats.lock() {
            stats.network_requests += 1;
            let elapsed = start.elapsed().as_millis() as f64;
            stats.avg_response_time_ms = 
                (stats.avg_response_time_ms * (stats.network_requests - 1) as f64 + elapsed) 
                / stats.network_requests as f64;
        }
        
        results
    }
    
    /// Perform actual web search (synchronous wrapper)
    fn perform_search(&self, query: &str) -> Vec<crate::ml::web_knowledge::SearchResult> {
        use crate::ml::web_knowledge::{WebScraperConfig, DuckDuckGoScraper};
        
        let config = WebScraperConfig {
            timeout_secs: self.config.timeout_secs,
            max_results: self.config.max_results,
            request_delay_ms: self.config.domain_delay_ms,
        };
        
        let mut scraper = DuckDuckGoScraper::new(config);
        
        // Respect rate limiting per domain
        self.wait_for_rate_limit("duckduckgo.com");
        
        match scraper.search(query) {
            Ok(results) => results,
            Err(e) => {
                if let Ok(mut stats) = self.stats.lock() {
                    stats.errors += 1;
                }
                eprintln!("Web search error for '{}': {}", query, e);
                Vec::new()
            }
        }
    }
    
    /// Wait for rate limit on domain
    fn wait_for_rate_limit(&self, domain: &str) {
        if let Ok(mut last_requests) = self.domain_last_request.lock() {
            let now = Instant::now();
            
            if let Some(last_time) = last_requests.get(domain) {
                let elapsed = last_time.elapsed();
                let delay = Duration::from_millis(self.config.domain_delay_ms);
                
                if elapsed < delay {
                    let wait_time = delay - elapsed;
                    std::thread::sleep(wait_time);
                }
            }
            
            last_requests.insert(domain.to_string(), Instant::now());
        }
    }
    
    /// Batch search multiple queries efficiently
    pub fn batch_search(&self, queries: &[String]) -> Vec<Vec<crate::ml::web_knowledge::SearchResult>> {
        let mut results = Vec::with_capacity(queries.len());
        
        // Check cache for all queries first
        let mut uncached_queries: Vec<(usize, String)> = Vec::new();
        
        for (idx, query) in queries.iter().enumerate() {
            if let Some(cached) = self.check_cache(query) {
                results.push((idx, cached));
            } else {
                uncached_queries.push((idx, query.clone()));
                results.push((idx, Vec::new())); // Placeholder
            }
        }
        
        // Process uncached queries with rate limiting
        for (original_idx, query) in uncached_queries {
            let search_results = self.perform_search(&query);
            self.save_to_cache(&query, &search_results);
            
            // Update the placeholder
            if let Some(entry) = results.iter_mut().find(|(idx, _)| *idx == original_idx) {
                entry.1 = search_results;
            }
            
            if let Ok(mut stats) = self.stats.lock() {
                stats.network_requests += 1;
            }
        }
        
        // Sort by original index and extract results
        results.sort_by_key(|(idx, _)| *idx);
        results.into_iter().map(|(_, r)| r).collect()
    }
    
    /// Extract and learn facts from search results
    pub fn learn_from_search(&self, query: &str) -> Vec<crate::ml::web_knowledge::WebKnowledge> {
        use crate::ml::web_knowledge::WebKnowledgeExtractor;
        
        let search_results = self.search(query);
        
        if search_results.is_empty() {
            return Vec::new();
        }
        
        let extractor = WebKnowledgeExtractor::new();
        extractor.extract_from_results(&search_results, query)
    }
    
    /// Batch learn from multiple queries
    pub fn batch_learn(&self, queries: &[String]) -> Vec<Vec<crate::ml::web_knowledge::WebKnowledge>> {
        let search_results = self.batch_search(queries);
        
        use crate::ml::web_knowledge::WebKnowledgeExtractor;
        let extractor = WebKnowledgeExtractor::new();
        
        queries
            .iter()
            .zip(search_results.iter())
            .map(|(query, results)| {
                extractor.extract_from_results(results, query)
            })
            .collect()
    }
}
